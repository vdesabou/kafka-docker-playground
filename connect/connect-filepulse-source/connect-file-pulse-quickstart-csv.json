{
    "connector.class": "io.streamthoughts.kafka.connect.filepulse.source.FilePulseSourceConnector",
    "filters": "ParseDelimitedRow, Drop",
    "filters.Drop.if": "{{ equals($value.artist, 'U2') }}",
    "filters.Drop.invert": "true",
    "filters.Drop.type": "io.streamthoughts.kafka.connect.filepulse.filter.DropFilter",
    "filters.ParseDelimitedRow.extractColumnName": "headers",
    "filters.ParseDelimitedRow.trimColumn": "true",
    "filters.ParseDelimitedRow.type": "io.streamthoughts.kafka.connect.filepulse.filter.DelimitedRowFilter",
    "fs.cleanup.policy.class": "io.streamthoughts.kafka.connect.filepulse.clean.LogCleanupPolicy",
    "fs.listing.class": "io.streamthoughts.kafka.connect.filepulse.fs.LocalFSDirectoryListing",
    "fs.scan.directory.path": "'"$DIRECTORY_PATH"'",
    "fs.listing.filters":"io.streamthoughts.kafka.connect.filepulse.fs.filter.RegexFileListFilter",
    "fs.listing.interval.ms": "10000",
    "file.filter.regex.pattern":".*\\.csv$",
    "offset.attributes.string": "name+hash",
    "skip.headers": "1",
    "topic": "connect-file-pulse-quickstart-csv",
    "tasks.reader.class": "io.streamthoughts.kafka.connect.filepulse.fs.reader.LocalRowFileInputReader",
    "tasks.file.status.storage.class": "io.streamthoughts.kafka.connect.filepulse.state.KafkaFileObjectStateBackingStore",
    "tasks.file.status.storage.bootstrap.servers": "broker:9092",
    "tasks.file.status.storage.topic": "connect-file-pulse-status",
    "tasks.file.status.storage.topic.partitions": 10,
    "tasks.file.status.storage.topic.replication.factor": 1,
    "tasks.max": 1,
    "internal.kafka.reporter.bootstrap.servers": "broker:9092",
    "internal.kafka.reporter.topic": "connect-file-pulse-status"
  }